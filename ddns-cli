#!/usr/bin/env python

## DDNS (Dynamic DNS) command line client / updater
##
## Easy to use command line utility for creating
## and updating forward and reverse DNS entries
## in dynamically updatable domains.
##
## Supports zones on different servers, supports
## different keys for each zone, automatically
## creates reverse record and removes obsoleted
## ones.
##
## Author: Michal Ludvig <mludvig@logix.net.nz>
##         http://www.logix.cz/michal/devel/ddns-cli
##
## License: GPL version 2
##

import os
import sys
import re
import socket
import argparse

import dns.query
import dns.tsigkeyring
import dns.update

ZONE_SERVER = {}
ZONE_KEY = {}
SERVER_KEY = {}
TTL_DEFAULT = 3600

execfile("ddns-cli.conf")

keyring = {}

class DDnsError(Exception):
    pass

class KeyNotFoundInFile(DDnsError):
    def __init__(self, key_file, key_name):
        self.key_file = key_file
        self.key_name = key_name

    def __str__(self):
        return "%s: %s" % (self.key_file, self.key_name)

class DDnsServerNotFound(DDnsError):
    def __str__(self):
        return "Server not found for zone: %s" % (self.message)

class ParameterError(DDnsError):
    pass

def debug(message):
    print("DEBUG: %s" % message)

def info(message):
    print("INFO: %s" % message)

def warning(message):
    print("WARNING: %s" % message)

def error(message):
    print("ERROR: %s" % message)

def parse_key_file(key_file, key_name):
    try:
        f = open(key_file, "r").read()
        pat = re.compile('key\s+[\'"]?(\S+?)[\'"]?\s*{.*?algorithm\s+[\'"]?([^\'";]+?)[\'"]?\s*;.*?secret\s+[\'"]?([^\'";]+?)[\'"]?\s*;.*?};', re.DOTALL | re.MULTILINE)
        for key in pat.finditer(f):
            key = list(key.groups())
            if key[1] == "hmac-md5":
                key[1] = "HMAC-MD5.SIG-ALG.REG.INT"
            if key[0] == key_name:
                return key
        raise KeyNotFoundInFile(key_file, key_name)

    except KeyNotFoundInFile, e:
        raise
    except Exception, e:
        sys.stderr.write("Can't parse a keyfile %s: %s\n" % (key_file, e))
        sys.exit(1)

def find_server(zone):
    """
    find_server(zone)

    Figure out server IP or name for a given 'zone'.
    Raise an exception if no suitable server is found.
    """
    if ZONE_SERVER.has_key(zone):
        return ZONE_SERVER[zone]
    elif ZONE_SERVER.has_key('default'):
        return ZONE_SERVER['default']
    raise DDnsServerNotFound(zone)

def find_key(zone, server):
    """
    find_key(zone, server) -> dns.tsigkeyring

    Figure out a signing key usable for a given zone.
    """
    key = None
    if ZONE_KEY.has_key(zone):
        key = ZONE_KEY[zone]
    elif SERVER_KEY.has_key(server):
        key = SERVER_KEY[server]
    if not key:
        raise KeyNotFound(zone, server)

    # key can have one of the following formats:
    # - inline key: 'algorithm:name:AbCd=='
    # - file with key name: '/etc/rndc.conf:ddns_key'
    if os.path.isfile(key.split(":")[0]):
        key_file, key_name = key.split(":", 1)
        key_name, key_algo, key_value = parse_key_file(key_file, key_name)
    else:
        key_algo, key_name, key_value = key.split(":", 2)
    debug("Key for zone '%s': %s:%s (%s)" % (zone, key_name, key_value, key_algo))
    return dns.tsigkeyring.from_text({key_name : key_value}), key_algo

class DDnsFQDN(str):
    pass

def parse_args():
    def _add_common_args(_parser, rrvalue_nargs = ""):
        _parser.add_argument("--config", type=file, help="Config file location")
        _parser.add_argument("--verbose", action="store_true", help="Verbose operation")
        _parser.add_argument("--debug", action="store_true", help="Extremely verbose operation")

        _parser.add_argument("--type", "-t", dest="rrtype", choices=("A", "AAAA"), help="Record type, e.g. A, AAAA, PTR, etc.")
        _parser.add_argument("--zone", "-z", dest="zone", type=DDnsFQDN, help="Zone to work with. By default for www.host.example.com the zone would be host.example.com, however you may instead want to put a record 'www.host' into the zone 'example.com'. In that case use --zone example.com.")
        _parser.add_argument("rrname", help="Resource Record Name")
        if rrvalue_nargs:
            _parser.add_argument("rrvalue", nargs=rrvalue_nargs, help="Resource Record Value")

    parser = argparse.ArgumentParser(prog="ddsn-cli")
    subparsers = parser.add_subparsers(dest = "command")

    parser_set = subparsers.add_parser("set", help="Create / update records")
    parser_set_group_add_replace = parser_set.add_mutually_exclusive_group()
    parser_set_group_add_replace.add_argument("--add", "-a", dest="replace", action="store_false", help="Add new record to existing ones.")
    parser_set_group_add_replace.add_argument("--replace", dest="replace", action="store_true", default="true", help="Replace all existing records of the same type with the new one. (default)")

    parser_set.add_argument("--ttl", dest="rrttl", type=int, default=TTL_DEFAULT, help="Time To Live")
    _add_common_args(parser_set, rrvalue_nargs = "+")

    #parser_get = subparsers.add_parser("get", help="Get all records for the given name")
    #_add_common_args(parser_get, rrvalue_nargs = None)

    parser_delete = subparsers.add_parser("delete", help="Delete some or all records for the given name")
    _add_common_args(parser_delete, rrvalue_nargs = "*")

    return parser.parse_args()

class DDnsCli(object):
    def __init__(self, args):
        self.args = args
        if args.command == "set":
            return self.cmd_set()
        #elif args.command == "get":
        #    return self.cmd_get()
        elif args.command == "delete":
            return self.cmd_delete()
        else:
            raise ParameterError("Unknown command: %s" % args.command)

    def compile_records(self):
        records = []
        if not self.args.rrtype:
            for rrvalue in self.args.rrvalue:
                rrtype = self.guess_rr_type(rrvalue)
                if not rrtype:
                    raise ParameterError("%s: Unable to guess RR type. Please use --type=..." % rrvalue)
                debug("Guessed: %s -> %s" % (rrvalue, rrtype))
                records.append({"rrtype":rrtype, "rrvalue":rrvalue})
        else:
            for rrvalue in self.args.rrvalue:
                if self.verify_rr_type(rrvalue, self.args.rrtype):
                    records.append({"rrtype":self.args.rrtype, "rrvalue":rrvalue})
                else:
                    raise ParameterError("%s: Not a valid %s type value" % (rrvalue, self.args.rrtype))
        return records

    def init_ddns_args(self):
        ddns_args = {}

        if self.args.zone:
            # Explicit zone was specified
            ddns_args['host'] = self.args.rrname.replace(self.args.zone, "")
            ddns_args['zone'] = self.args.zone
        else:
            # No explicit zone. Guess it from FQDN (rrname)
            try:
                ddns_args['host'], ddns_args['zone'] = self.args.rrname.split(".", 1)
            except ValueError:
                raise ParameterError("%s: Hostname is not fully qualified. Append your domain please." % self.args.rrname)

        ddns_args['host'] = ddns_args['host'].strip(".")
        ddns_args['zone'] = ddns_args['zone'].strip(".")

        ddns_args['server'] = find_server(ddns_args['zone'])
        info("Server for zone '%(zone)s': %(server)s" % ddns_args)
        ddns_args['keyring'], ddns_args['keyalgorithm'] = find_key(ddns_args['zone'], ddns_args['server'])

        return ddns_args

    def guess_rr_type(self, rrvalue):
        if self.verify_rr_type(rrvalue, "A"):
            return "A"
        if self.verify_rr_type(rrvalue, "AAAA"):
            return "AAAA"
        return None

    def verify_rr_type(self, rrvalue, rrtype):
        if rrtype == "A":
            try:
                socket.inet_pton(socket.AF_INET, rrvalue)
                # inet_pton() accepts shortened IPv4 addresses,
                # e.g. "127.1" - we don't allow that. Count the
                # number of '.' in the address to make sure it's
                # in a quad-byte form.
                return rrvalue.count('.') == 3
            except socket.error:
                return False
        if rrtype == "AAAA":
            try:
                socket.inet_pton(socket.AF_INET6, rrvalue)
                return True
            except socket.error:
                return False
        error("Unsupported RR type: %s" % rrtype)
        return False

    def verify_fqdn(self, rrvalue):
        return rrvalue.count(".") > 0

    def cmd_set(self):
        ddns_args = self.init_ddns_args()
        records = self.compile_records()

        for record in records:
            ddns_args['rrvalue'] = record["rrvalue"]
            ddns_args['rrtype'] = record["rrtype"]
            ddns_args['ttl'] = self.args.rrttl

            debug("ddns_args: %r" % ddns_args)
            update = dns.update.Update(ddns_args['zone'], keyring=ddns_args['keyring'], keyalgorithm = ddns_args['keyalgorithm'])
            if self.args.replace:
                update.replace(ddns_args['host'], ddns_args['ttl'], ddns_args['rrtype'], ddns_args['rrvalue'])
            else:
                update.add(ddns_args['host'], ddns_args['ttl'], ddns_args['rrtype'], ddns_args['rrvalue'])
            response = dns.query.tcp(update, ddns_args['server'])
            info("%s(%s, %s): %s" % (self.args.rrname, ddns_args['rrvalue'], ddns_args['rrtype'], dns.rcode.to_text(response.rcode())))

    def cmd_delete(self):
        raise

if __name__ == "__main__":
    args = parse_args()
    try:
        ddns_cli = DDnsCli(args)
    except DDnsError, e:
        sys.stderr.write("ERROR: %s\n" % e)

# vim:expandtab:ts=4:softtabstop=4:autoindent
